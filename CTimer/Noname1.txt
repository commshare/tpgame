  对于一个游戏而言，定时器是必须的，而它一般作为一个游戏基本公共组件，而定时器在游戏逻辑中运用是非常明显的(比如吃药回血，每几秒回血多少)，
  而对于游戏逻辑而言需要开发一个高效率高精度(毫秒级别)的定时器。

一：分析几种库定时器实现方式
   1.Ace
      1）
      2）
      3）
      4）

   2.Boost
      1）

二；一种采用linux中断处理的定时器设计方式
   定时器是基于时间的中断函数，即是根据触发时间来超时响应。所以只要我们设计一个基于时间的Hash算法。
只要我们能我们把一个函数触发时间全部Hash到此Hash桶中，就实现了查找，插入，删除O(1)的操作了，其实不然
基于时间的hash算法好像挺复杂，而且桶的数量太大，内存消耗太多，所以把一个时间直接Hash代价太大。
   
  而公司游戏的定时器是基于Ace的时间轮方式设计的：
   
  
  而本文介绍的参考了Linux中断处理，主要采用的是一种把时间Hash到5个轮子中，只触发第一个轮子的定时器，维护后面
4个轮子的所有定时器。

为什么5个轮子就能完全满足所有的定时器触发列队。
  一个 32bits 的整数，如果精确到1毫秒，则2^32位可以表示49.3天而一般服务器不会直接运行49.3天，
每一个轮子表示方位在0~256, 256~256*64, 256*64~256*64^2, 256*64^2~256*64^3, 256*64^3~256*64^4, 
假设这里精度为n毫秒，第一个轮子表示n*256秒时间内触发函数，第二个轮子的第二个插孔则表示n*256*2时间范围内的，
也就是只有当前面一个轮子转一圈后面一个轮在才会动一格，后面一格的定时器时间范围则是前面一个轮子一圈的范围。
最经典的例子就是生活中的水表，第一个指针转一圈后一个转一格，以此类推，，



在内核动态定时器机制的实现中，有三个操作时非常重要的：
（1）将一个定时器插入到它应该所处的定时器向量中。
（2）定时器的迁移，也即将一个定时器从它原来所处的定时器向量迁移到另一个定时器向量中。
（3）扫描并执行当前已经到期的定时器。 


  